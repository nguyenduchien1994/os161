Design Report
Julia Isaac, Tristan Johnson and Hien Nguyen
 
Process Management
We are going to use a one-to-one mapping of kernel threads to user processes.  

PCB
To make a user process, we will need to construct a new PCB. Then add it to global management, making the state of the process being ready. We will also need to aquire the process lock before we can call schedule. We will also be adding a "exit cv" to the PCB. In addition, we will add an exit code to the PCB. 

Scheduler
When scheduling we will need to first make sure that the current process and the current thread are correct and correctly mapped to each other, as well as making user that it is in the ready state. Once these checks are doen we will release the lock, then thread_yield() because it is one-to-one. Next, we will acquire lock making the process fun. Then we will make the current process equal the current thread mapping. 

Global Management
In the global management, we will have an array of all the processes and an array of the all the threads. Both arrays will be mapped to each other by the indices and the maximum length will be 256. The Global Management will also have a process lock. 

Handling File Systems
Open Tracking
In the PCB, we will have an array of files that are open and the maximum length of the file is 32. To keep track of all of the files the next available slot we will use a stack. We will then give the vnode a "p-lock". This way in order to access, we need to own the p_lock and if we own it then we can added it to our list of open files list and this will be atomic. When we remove the file from our list by closing the file, we will release the p_lock. We are also planning on using the file system directly instead of creating our own large list of files. If the process trys to open or own too many files, we will kill the process. 

Syscalls
open
We will call vfs_open and then aquire the lock and to list.

read
We will call vop_read.

write
We will call vop_write. 

lseek
We will call dev_isseekable to check and then if we can we will edit the pos variable to be the new and correct off_t. 

close
We will first remove from list. Next we will call vfs_close and then release lock.

dup2
We will create a new file that we will write to. We will then read from the oringal file and write what is read from the orginal file to the new file. 

chdir
We will call vfs_chdir. 

__getcwd
We will call vfs_getcwd. 

getpid
Return the value from the current process PCB, which is accessed by using the mapping in the global management.

fork
Create new PCB, and sets it up to be ready. This identical to the oringal PCB execpt the pid will differ and the program counter will be set to zero.  

execv
This will call runprogram.  

waitpid
This will first assert that the PID exists and it doesn't it will set the status to an error exit code, such as -1 or NULL. This will wait on the "exit cv" and then set the status to be the exit code associated with the exited process. Then we call P() on the kill semaphore. 

_exit
  It will look for the pid_t in the global manager and get the exit code from the manager. Once a process exits a semaphore will be made.  This will then boardcast to the "exit cv". Call V() n times for n waiting, and then delete and bookeep current process in global manager.


Working as a team
Each team member will get a series of syscalls they will be responible to implement. Every few days we will me to make sure everyone is on track with the syscalls they have implemented. In these meetings, we will be making sure that everyone is keeping up with what they are implementing to ensure everything will be done on time.

We will work as a group by having group meetings very few days and communicate with each other through group messages. In the group messages, we will inform our teammates when we are working on the project to ensure we are avoiding merge conflits. 
